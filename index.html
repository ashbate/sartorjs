<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Graph Network</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: transparent;
      overflow: hidden;
    }

    svg {
      width: 100vw;
      height: 100vh;
    }

    circle {
      fill: #69b3a2;
      stroke: #333;
      stroke-width: 1.5px;
    }

    line {
      stroke: #aaa;
      stroke-width: 6px;
    }

    .trace {
      fill: none;
      stroke: #ff5733;
      stroke-width: 3px;
      stroke-linecap: round;
    }

    .dot {
      fill: #ff5733;
      r: 8;
    }
  </style>
</head>
<body>
  <svg></svg>

  <script>
    const nodes = [
      { id: "Logo1", x: 150, y: 300 },
      { id: "Logo2", x: 150, y: 400 },
      { id: "Middle", x: 500, y: 350 },
      { id: "Logo3", x: 850, y: 300 },
      { id: "Logo4", x: 850, y: 400 },
    ];

    // Path with waypoints for rectangular route
    const links = [
      { source: "Logo1", target: "Middle" },
      { source: "Logo2", target: "Middle" },
      { source: "Middle", target: "Logo3" },
      { source: "Middle", target: "Logo4" },
    ];

    const svg = d3.select("svg");

    // Draw links
    const link = svg.selectAll("path")
      .data(links)
      .join("path")
      .attr("d", d => {
        const source = nodes.find(n => n.id === d.source);
        const target = nodes.find(n => n.id === d.target);
        // Create a rectangular path by having waypoints to make the connection more "road-like"
        const midX = (source.x + target.x) / 2;
        return `M${source.x},${source.y} 
                L${midX},${source.y} 
                L${midX},${target.y} 
                L${target.x},${target.y}`;
      })
      .attr("fill", "none")
      .attr("stroke", "#aaa")
      .attr("stroke-width", 6)
      .attr("stroke-linejoin", "round");

    // Draw nodes
    svg.selectAll("circle")
      .data(nodes)
      .join("circle")
      .attr("cx", d => d.x)
      .attr("cy", d => d.y)
      .attr("r", 20)
      .attr("fill", (d, i) => i === 2 ? "#FFD700" : "#69b3a2");

    // Add text labels
    svg.selectAll("text")
      .data(nodes)
      .join("text")
      .attr("x", d => d.x)
      .attr("y", d => d.y - 30)
      .attr("text-anchor", "middle")
      .text(d => d.id);

    // Animate dot with trace
    function animateDot() {
      const path = links.map(d => {
        const source = nodes.find(n => n.id === d.source);
        const target = nodes.find(n => n.id === d.target);
        const midX = (source.x + target.x) / 2;
        return [
          { x: source.x, y: source.y },
          { x: midX, y: source.y },
          { x: midX, y: target.y },
          { x: target.x, y: target.y }
        ];
      }).flat();

      const trace = svg.append("path")
        .attr("class", "trace")
        .attr("d", ""); // Empty initially

      const dot = svg.append("circle").attr("class", "dot").attr("r", 8);

      let pointIndex = 0;
      const totalPoints = path.length;

      function moveDot() {
        if (pointIndex >= totalPoints - 1) {
          dot.remove();
          trace.remove();
          setTimeout(animateDot, 1000); // Start the animation again after a delay
          return;
        }

        const { x: x1, y: y1 } = path[pointIndex];
        const { x: x2, y: y2 } = path[pointIndex + 1];

        // Update trace path
        const currentPath = trace.attr("d");
        const newPathSegment = `M${x1},${y1} L${x2},${y2}`;
        trace.attr("d", currentPath ? `${currentPath} ${newPathSegment}` : newPathSegment);

        dot.attr("cx", x1).attr("cy", y1);

        dot.transition()
          .duration(2000) // Slower movement for visibility
          .attr("cx", x2)
          .attr("cy", y2)
          .on("end", () => {
            pointIndex++;
            moveDot();
          });
      }

      moveDot();
    }

    // Start the animation
    animateDot();
  </script>
</body>
</html>
